# Sistema de Controle de FinanÃ§as Pessoais

Um sistema web completo para gerenciamento de finanÃ§as pessoais, construÃ­do com foco em usabilidade e seguranÃ§a. Permite o registro de receitas e despesas, anexo de comprovantes, e visualizaÃ§Ã£o de um dashboard financeiro intuitivo.
---

## DescriÃ§Ã£o

Sistema desenvolvido para controle financeiro pessoal que permite aos usuÃ¡rios:
- Criar conta e fazer login de forma segura.
- Registrar receitas e despesas por categoria.
- Anexar cupons fiscais em PDF.
- Visualizar saldo atual, total de receitas e despesas.
- Consultar histÃ³rico completo de transaÃ§Ãµes.

Este projeto foi criado para oferecer uma soluÃ§Ã£o simples e eficaz para o controle financeiro pessoal. A plataforma permite que os usuÃ¡rios cadastrem-se, registrem suas transaÃ§Ãµes diÃ¡rias (receitas e despesas), e acompanhem sua saÃºde financeira atravÃ©s de um painel de controle claro e objetivo.
---

## Tecnologias Utilizadas

### Backend
- **Node.js**
- **Express.js**
- **MySQL2**
- **bcrypt** 
- **express-validator**
- **helmet**
- **express-rate-limit**
- **xss-clean** 
- **hpp**
- **multer**
- **dotenv**

### Frontend
- **React**
- **Tailwind CSS**

### Banco de Dados
- **MySQL**

##  Funcionalidades

- âœ… Cadastro e login de usuÃ¡rio.
- âœ… Adicionar receitas.
- âœ… Adicionar suas despesas pessoais.
- âœ… Upload de cupom fiscal.
- âœ… VisualizaÃ§Ã£o de saldo.
- âœ… HistÃ³rico de transaÃ§Ãµes.

---

## SeguranÃ§a

O sistema possui proteÃ§Ãµes contra as seguintes vulnerabilidades:

### 1. SQL Injection 
**ProteÃ§Ã£o:** Queries parametrizadas em 100% das consultas

### 2. Cross-Site Scripting (XSS) âœ…
**ProteÃ§Ã£o:** SanitizaÃ§Ã£o de inputs + Helmet + CSP

### 3. Cross-Site Request Forgery (CSRF) âœ…
**ProteÃ§Ã£o:** CORS restrito + ValidaÃ§Ã£o de origem

### 4. Mass Assignment âœ…
**ProteÃ§Ã£o:** Whitelist de campos permitidos

### 5. Session Hijacking âœ…
**ProteÃ§Ã£o:** Rate limiting + Bcrypt forte

### 6. Hardcoded SQL âœ…
**ProteÃ§Ã£o:** 0% de SQL hardcoded - 100% parametrizado

---

## ğŸ“¦ InstalaÃ§Ã£o

### PrÃ©-requisitos
1. **Node.js**
2. **XAMPP**

### Passo 1: Configurar Banco de Dados

1. Inicie o **XAMPP** e ligue o **MySQL**
2. Acesse http://localhost/phpmyadmin
3. Crie o banco `bd_fintech`
4. Execute o script `database.sql`

### Passo 2: Backend

```bash
cd backend
npm install express mysql2 cors bcrypt multer express-validator helmet express-rate-limit xss-clean hpp cookie-parser dotenv
copy .env.example .env
#edita o env com as variaveis de ambiente
npm start
```

### Passo 3: Frontend

```bash
cd frontend
npm install
npm install -D tailwindcss@3.4.1 postcss autoprefixer
npm install lucide-react
npx tailwindcss init -p
npm start
```

---

## Como Executar

### Iniciar Backend
```bash
cd backend
npm start
# Servidor backend rodando em: http://localhost:3001
```

### Iniciar Frontend
```bash
cd frontend
npm start
# Servidor frontend rodando em: http://localhost:3000
```

---

## Estrutura do Projeto

```
FintechSegura/
â”œâ”€â”€ backend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ config/
â”‚   â”‚   â”‚   â””â”€â”€ database.js
â”‚   â”‚   â”œâ”€â”€ controllers/
â”‚   â”‚   â”‚   â”œâ”€â”€ authController.js
â”‚   â”‚   â”‚   â””â”€â”€ transactionController.js
â”‚   â”‚   â”œâ”€â”€ routes/
â”‚   â”‚   â”‚   â”œâ”€â”€ authRoutes.js
â”‚   â”‚   â”‚   â””â”€â”€ transactionRoutes.js
â”‚   â”‚   â”œâ”€â”€ middleware/
â”‚   â”‚   â”‚   â”œâ”€â”€ uploadMiddleware.js
â”‚   â”‚   â”‚   â”œâ”€â”€ validationMiddleware.js
â”‚   â”‚   â”‚   â””â”€â”€ securityMiddleware.js
â”‚   â”‚   â””â”€â”€ app.js
â”‚   â”œâ”€â”€ uploads/
â”‚   â”œâ”€â”€ server.js
â”‚   â”œâ”€â”€ package.json
â”‚   â””â”€â”€ .env
â”œâ”€â”€ frontend/
â”‚   â”œâ”€â”€ src/
â”‚   â”‚   â”œâ”€â”€ App.js
â”‚   â”‚   â””â”€â”€ index.css
â”‚   â””â”€â”€ package.json
â””â”€â”€ database.sql
```

---

## ğŸ”Œ API Endpoints

### POST `/api/register`
Cadastrar usuÃ¡rio
```json
{
  "name": "JoÃ£o Silva",
  "email": "joao@email.com",
  "password": "Senha123"
}
```

### POST `/api/login`
Fazer login
```json
{
  "email": "joao@email.com",
  "password": "Senha123"
}
```

### POST `/api/transactions`
Criar transaÃ§Ã£o (multipart/form-data)

### GET `/api/transactions/:userId`
Listar transaÃ§Ãµes

### DELETE `/api/transactions/:id`
Deletar transaÃ§Ã£o

### GET `/api/stats/:userId`
Obter estatÃ­sticas

## AnÃ¡lise e Tratamento de Vulnerabilidades

A seguranÃ§a foi um pilar central no desenvolvimento. Abaixo, detalhamos as principais vulnerabilidades e como o sistema as tratou:

### 1. Cross-Site Scripting (XSS)
- **AmeaÃ§a:** Um invasor injeta scripts maliciosos (ex: `<script>`) nos campos de entrada da aplicaÃ§Ã£o (como a descriÃ§Ã£o de uma transaÃ§Ã£o). Esses scripts sÃ£o entÃ£o executados no navegador de outros usuÃ¡rios, podendo roubar cookies de sessÃ£o ou realizar aÃ§Ãµes em nome da vÃ­tima.
- **SoluÃ§Ã£o Implementada:** Utilizamos o middleware `xss-clean`, que automaticamente sanitiza qualquer dado enviado no corpo (`body`), nos parÃ¢metros de consulta (`query`) e nos parÃ¢metros de URL (`params`). Ele remove ou codifica caracteres perigosos, garantindo que nenhuma entrada do usuÃ¡rio possa ser executada como cÃ³digo no navegador.

### 2. SQL Injection
- **AmeaÃ§a:** Um invasor insere comandos SQL maliciosos nos campos de entrada para manipular as consultas ao banco de dados. Isso pode permitir que ele visualize, modifique ou exclua dados de toda a aplicaÃ§Ã£o, incluindo informaÃ§Ãµes de outros usuÃ¡rios.
- **SoluÃ§Ã£o Implementada:** Nenhuma consulta ao banco de dados Ã© construÃ­da por concatenaÃ§Ã£o de strings. Utilizamos **consultas parametrizadas (prepared statements)**. Com essa tÃ©cnica, o comando SQL e os dados do usuÃ¡rio sÃ£o enviados ao banco de dados separadamente, garantindo que a entrada seja sempre tratada como dados e nunca como cÃ³digo SQL executÃ¡vel.

### 3. Cross-Site Request Forgery (CSRF)
- **AmeaÃ§a:** Um invasor engana um usuÃ¡rio autenticado para que ele execute uma aÃ§Ã£o indesejada na aplicaÃ§Ã£o. Por exemplo, um link em um e-mail malicioso poderia, ao ser clicado, fazer uma requisiÃ§Ã£o para a API e excluir uma transaÃ§Ã£o sem que o usuÃ¡rio perceba.
- **SoluÃ§Ã£o Implementada:** O backend possui uma polÃ­tica de **CORS (Cross-Origin Resource Sharing)** estrita. A API sÃ³ aceita requisiÃ§Ãµes vindas da origem especÃ­fica do frontend (ex: `http://localhost:3000`). Isso impede que qualquer outro site na internet consiga fazer requisiÃ§Ãµes vÃ¡lidas para a nossa API, bloqueando efetivamente os ataques CSRF vindos de origens externas.

### 4. Ataques de ForÃ§a Bruta (Brute Force)
- **AmeaÃ§a:** Um invasor utiliza scripts automatizados para testar milhÃµes de combinaÃ§Ãµes de senhas na tela de login, com o objetivo de adivinhar a senha de um usuÃ¡rio.
- **SoluÃ§Ã£o Implementada:** Implementamos um **Rate Limiter** (`express-rate-limit`) nas rotas de autenticaÃ§Ã£o (`/api/login`, `/api/register`). Este middleware limita o nÃºmero de tentativas de login que um mesmo endereÃ§o IP pode fazer em um determinado intervalo de tempo. ApÃ³s um pequeno nÃºmero de falhas, o IP Ã© temporariamente bloqueado, tornando os ataques de forÃ§a bruta ineficazes.

### 5. ExposiÃ§Ã£o de InformaÃ§Ãµes SensÃ­veis e CabeÃ§alhos Inseguros
- **AmeaÃ§a:** O servidor pode, por padrÃ£o, enviar cabeÃ§alhos HTTP que revelam informaÃ§Ãµes sobre as tecnologias utilizadas (ex: `X-Powered-By: Express`), facilitando a vida de um invasor. AlÃ©m disso, a falta de cabeÃ§alhos de seguranÃ§a pode expor a aplicaÃ§Ã£o a ataques como o clickjacking.
- **SoluÃ§Ã£o Implementada:** Utilizamos o `helmet`, uma coleÃ§Ã£o de middlewares de seguranÃ§a que:
    - Remove o cabeÃ§alho `X-Powered-By`.
    - Adiciona proteÃ§Ã£o contra clickjacking (`X-Frame-Options`).
    - Implementa uma **PolÃ­tica de SeguranÃ§a de ConteÃºdo (CSP)** para prevenir a injeÃ§Ã£o de recursos de fontes nÃ£o confiÃ¡veis.
    - Aplica outras 11 melhorias de seguranÃ§a nos cabeÃ§alhos HTTP.

### 6. Armazenamento Inseguro de Senhas
- **AmeaÃ§a:** Se o banco de dados for comprometido e as senhas estiverem armazenadas em texto plano ou com criptografia fraca, todas as contas de usuÃ¡rio serÃ£o instantaneamente comprometidas.
- **SoluÃ§Ã£o Implementada:** As senhas nunca sÃ£o armazenadas diretamente. Utilizamos a biblioteca `bcrypt` para gerar um **hash salgado** de cada senha. O "sal" (um valor aleatÃ³rio) garante que senhas iguais resultem em hashes diferentes, e a natureza lenta do bcrypt torna inviÃ¡vel a quebra de senhas por forÃ§a bruta mesmo que um invasor tenha acesso aos hashes.
